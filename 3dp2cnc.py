'''
Fetch an image, vector-fill it via the first-left diagonal algorithm and convert it to a set of
GCode instructions for a 3D Printer controller. The ultimate goal is to let the printer head "draw"
the desired image, either via pencil, or via a drill thus converting it to a CNC mill.

Remarks:
* Marlin GCode dialect
* The origin at the start will be the absolute movement origin, right-top-up orientation
* Assume the drill bit starts at the bottom left and Z=drilling the surface at desired depth
* Perform the test swipe around the drilled area and wait for confirmation before drilling
* Requires separately configurable X-Y and Z speeds due to mechanical reasons (direct vs wormgear)

oton.ribic@bug.hr
'''

import vectorizer
from PIL import Image as pil

# Some statics

# GCode initializations
GCodeHeader = ['M82;Absolute mode',
               'G92 X0 Y0 Z0 E0;Reset coordinate system',
               'M107;Fans off',
               'M17;Enable motors',
               ]
GCodeFooter = ['M84 X Y E;Release motors',
               ]

# Main bitmap -> vector GCode processing


def img2cnc(
    inputfile,  # Image file w/ path or PIL handle directly
    outputfile=None,  # Autogenerated if not supplied
    invertpixels=True,  # Whether to consider black pixels "true" instead of white
    scale=0.1,  # How many GCode millimeters per pixel in the image (0.1 = 10 pixels per mm)
    moveextents=True,  # Move head over extents and require confirmation before start
    hopheight=2,  # Height of the head above the drilling depth while traversing (mm)
    tspeedxy=100,  # Traversal speed in X-Y (mm/s)
    dspeedxy=1.5,  # Drill speed in X-Y (mm/s)
    tspeedz=5,  # Traversal (retraction) speed in Z (mm/s)
    dspeedz=0.6,  # Sink speed in Z (mm/s)
    negativey=True,  # Whether to invert Y axis (required on Marlin e.g.)
    diag=False,  # Diagnostics mode to export tracks to SVG (requires SVGGEN)
):
    '''Main one converting image to a GCode file'''

    # Get vector "list of lists"
    vectors = vectorizer.vectorize(
        inputfile,
        method='f',
        invertpixels=invertpixels,
        splittogrid=(500, 500),
        calibrator=None,
        reverseall=True,
        negativey=negativey,
    )
    # Export SVG if in diagnostics mode
    if diag:
        try:
            import svggen
            svggen.svggen(vectors, inputfile + '.svg')
        except BaseException:
            print('No SVGGEN library available')
    # Calculate scaling and extents
    allx, ally = set(), set()  # Collectors
    for sid, shape in enumerate(vectors):
        for pid, point in enumerate(shape):
            # Point-per-point
            nx, ny = round(point[0] * scale, 3), round(point[1] * scale, 3)
            vectors[sid][pid] = (nx, ny)
            # Collectors for extent calculations
            allx.add(nx)
            ally.add(ny)
    extents = min(allx), min(ally), max(allx), max(ally)

    # Normalize speeds to GCode/GRBL unit: mm/min (from mm/s)
    tspeedxy = round(tspeedxy * 60)
    dspeedxy = round(dspeedxy * 60)
    tspeedz = round(tspeedz * 60)
    dspeedz = round(dspeedz * 60)

    # Show to the user
    print('Extents (x1,y1,x2,y2) mm:', extents)
    print('Size (x,y) mm:', extents[2] - extents[0], extents[3] - extents[1])

    gcode = []  # Collector of instructions to be assembled later
    # Perform initial hop to height's initial position
    gcode.append('G0 F{0} Z{1}'.format(tspeedz, hopheight))
    # Show extents if required
    if moveextents:
        gcode.append('G0 X{0} Y{1} F{2};Top left'.format(extents[0], extents[3], tspeedxy))
        gcode.append('M0 Confirm Top Left;Wait for confirmation')
        gcode.append('G0 X{0} Y{1} F{2};Bottom right'.format(extents[2], extents[1], tspeedxy))
        gcode.append('M0 Confirm Bot Right;Wait for confirmation')
    # Head is now in position.
    # Process vectors step-by-step, considering head hops and relative speeds. Note that
    # the GCode controller, by the point of the first instructions, has already been
    # switched to absolute motor positioning mode, which corresponds to the coordinate system
    # of the vectors.
    gcode.append('M117 Drilling...')
    for shape in vectors:
        # Assume head is up, move above the entry point
        gcode.append('G0 X{0} Y{1} F{2}'.format(shape[0][0], shape[0][1], tspeedxy))
        gcode.append('G0 Z0 F{0}'.format(dspeedz))
        for point in shape[1:]:
            # Step to point
            gcode.append('G0 X{0} Y{1} F{2}'.format(point[0], point[1], dspeedxy))
        # Retract drill to hop height at the end of shape
        gcode.append('G0 F{0} Z{1}'.format(tspeedz, hopheight))
    # After all shapes, return to the origin point
    gcode.append('G0 X0 Y0 F{0}'.format(tspeedxy))
    gcode.append('G0 Z0 F{0}'.format(dspeedz))

    # Completed the code itself. Append headers and footers
    gcode = GCodeHeader + gcode + GCodeFooter

    # Assemble into a file
    if not outputfile:
        outputfile = inputfile + '.gcode'
    outf = open(outputfile, 'w', encoding='ANSI')
    outf.write('\n'.join(gcode))
    outf.close()
    print('All done, instructions written:', len(gcode))


### Ran as main?
################
if __name__ == '__main__':
    img2cnc('inputs\\pcbsample.png')
    # img2cnc('inputs\\24x24.png')
    # img2cnc('inputs\\sampleprint.png')
    img2cnc('inputs\\funkcionira.png')